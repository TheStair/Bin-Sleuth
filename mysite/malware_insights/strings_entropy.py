# Runs Strings
import re
import sys
import lief
import numpy as np
from scipy.stats import entropy
from pathlib import Path

def extract_strings(input_file, min_length: int):
    """
    Return a list of all ASCII‐printable substrings in `data`
    of at least `min_length` characters.
    """
    # [\x20-\x7E] is the range of printable ASCII (space through tilde)
    with open(input_file, "rb") as f:
        data = f.read()

    print("Running Strings")
    pattern = re.compile(rb'[\x20-\x7E]{%d,}' % min_length)
    return [match.decode('ascii', errors='ignore')
            for match in pattern.findall(data)]





def shannon_entropy(data: bytes) -> float:
    """Compute Shannon entropy (base‑2) of a bytes object."""
    if not data:
        return 0.0
    arr = np.frombuffer(data, dtype=np.uint8)
    counts = np.bincount(arr, minlength=256)
    probs = counts / counts.sum()
    probs = probs[probs > 0]               # drop zero‑probability symbols
    return entropy(probs, base=2)          # bits per byte

def compute_section_entropies(input_file) -> dict[str, float]:
    """Parse the binary at `path` and return a dict of section→entropy."""
    binary = lief.parse(input_file)
    entropies: dict[str, float] = {}
    for sec in binary.sections:
        raw = bytes(sec.content)           # LIEF gives section.content as List[int]
        ent = shannon_entropy(raw)
        entropies[sec.name] = ent
    return entropies

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python entropy.py <path-to-binary>")
        sys.exit(1)

    path = sys.argv[1]
    path = Path(path)
    if not path.exists():
        print(f"File not found: {path}")
        sys.exit(1)
    ents = compute_section_entropies(path)
    for name, e in ents.items():
        print(f"{name:15} {e:.2f} bits/byte")
