{
  "address": "0x166a",
  "rules": [
    "populate SysWhispers2 syscall list/bac71c42a489454d9c62b98a7189c5d2",
    "decompress data using aPLib/88da69e00a6e49ce8c080be3a0beeb89",
    "hash data using aphash/53c84e7b18b64c82aa36e25c45372fcd",
    "contain loop",
    "hash data with CRC32/7620b456d97a4aaeb63e1213270df3d4",
    "encrypt data using RC4 KSA/ce2c5ff22cc84a5d8021901651b76a23",
    "write file on Windows/035d57bed47747649158312e9532f27d",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e",
    "check for kernel debugger via shared user data structure/f02b2044f10f450f9f5b2b0d5d96cef0",
    "hash data with CRC32/dc8063c9cb1c41b9a5bafe66f5117ac4"
  ],
  "disassembly": [
    "endbr64 ",
    "push    rbp {__saved_rbp}",
    "mov     rbp, rsp {__saved_rbp}",
    "sub     rsp, 0x50",
    "mov     qword [rbp-0x48 {var_50}], rdi",
    "mov     qword [rbp-0x50 {var_58}], rsi",
    "mov     rax, qword [fs:0x28]",
    "mov     qword [rbp-0x8 {var_10}], rax",
    "xor     eax, eax  {0x0}",
    "mov     qword [rbp-0x40 {var_48}], 0x0",
    "mov     rax, qword [rbp-0x48 {var_50}]",
    "mov     qword [rbp-0x38 {var_40}], rax",
    "jmp     0x16d0",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "movzx   eax, byte [rax]",
    "test    al, al",
    "jne     0x169f",
    "call    __ctype_b_loc",
    "mov     rdx, qword [rax]",
    "mov     rax, qword [rbp-0x38 {var_40}]",
    "movzx   eax, byte [rax]",
    "movzx   eax, al",
    "add     rax, rax",
    "add     rax, rdx",
    "movzx   eax, word [rax]",
    "movzx   eax, ax",
    "and     eax, 0x2000",
    "test    eax, eax",
    "jne     0x16cb",
    "mov     rax, qword [rbp-0x40 {var_48}]",
    "and     eax, 0x1",
    "test    rax, rax",
    "je      0x16f1",
    "add     qword [rbp-0x38 {var_40}], 0x1",
    "add     qword [rbp-0x40 {var_48}], 0x1",
    "mov     rax, qword [rbp-0x40 {var_48}]",
    "shr     rax, 0x1",
    "mov     qword [rbp-0x20 {var_28_1}], rax",
    "mov     rax, qword [rbp-0x20 {var_28_1}]",
    "mov     rdi, rax",
    "call    malloc",
    "mov     qword [rbp-0x18 {var_20_1}], rax",
    "cmp     qword [rbp-0x18 {var_20_1}], 0x0",
    "jne     0x171d",
    "mov     eax, 0x0",
    "jmp     0x17e5",
    "mov     qword [rbp-0x30 {i}], 0x0",
    "mov     qword [rbp-0x28 {var_30_1}], 0x0",
    "jmp     0x17c1",
    "mov     eax, 0x0",
    "jmp     0x17e5",
    "mov     rdx, qword [rbp-0x8 {var_10}]",
    "sub     rdx, qword [fs:0x28]",
    "je      0x17f9",
    "mov     rax, qword [rbp-0x30 {i}]",
    "cmp     rax, qword [rbp-0x20 {var_28_1}]",
    "jb      0x1737",
    "leave    {__saved_rbp}",
    "retn     {__return_addr}",
    "call    __stack_chk_fail",
    "{ Does not return }",
    "call    __ctype_b_loc",
    "mov     rax, qword [rax]",
    "mov     rcx, qword [rbp-0x48 {var_50}]",
    "mov     rdx, qword [rbp-0x28 {var_30_1}]",
    "add     rdx, rcx",
    "movzx   edx, byte [rdx]",
    "movzx   edx, dl",
    "add     rdx, rdx",
    "add     rax, rdx",
    "movzx   eax, word [rax]",
    "movzx   eax, ax",
    "and     eax, 0x2000",
    "test    eax, eax",
    "jne     0x1732",
    "cmp     qword [rbp-0x50 {var_58}], 0x0",
    "je      0x17e1",
    "add     qword [rbp-0x28 {var_30_1}], 0x1",
    "mov     rdx, qword [rbp-0x48 {var_50}]",
    "mov     rax, qword [rbp-0x28 {var_30_1}]",
    "add     rax, rdx",
    "movzx   eax, byte [rax]",
    "mov     byte [rbp-0xb {nptr}], al",
    "mov     rax, qword [rbp-0x28 {var_30_1}]",
    "lea     rdx, [rax+0x1]",
    "mov     rax, qword [rbp-0x48 {var_50}]",
    "add     rax, rdx",
    "movzx   eax, byte [rax]",
    "mov     byte [rbp-0xa {var_12_1}], al",
    "mov     byte [rbp-0x9 {var_11_1}], 0x0",
    "lea     rax, [rbp-0xb {nptr}]",
    "mov     edx, 0x10",
    "mov     esi, 0x0",
    "mov     rdi, rax {nptr}",
    "call    strtol",
    "mov     rcx, rax",
    "mov     rdx, qword [rbp-0x18 {var_20_1}]",
    "mov     rax, qword [rbp-0x30 {i}]",
    "add     rax, rdx",
    "mov     edx, ecx",
    "mov     byte [rax], dl",
    "add     qword [rbp-0x28 {var_30_1}], 0x2",
    "add     qword [rbp-0x30 {i}], 0x1",
    "mov     rax, qword [rbp-0x18 {var_20_1}]",
    "mov     rax, qword [rbp-0x50 {var_58}]",
    "mov     rdx, qword [rbp-0x20 {var_28_1}]",
    "mov     qword [rax], rdx"
  ],
  "high_level_IL": [
    "void* fsbase",
    "int64_t rax = *(fsbase + 0x28)",
    "int64_t var_48 = 0",
    "char* var_40 = arg1",
    "while (*var_40 != 0)",
    "uint16_t* rdx_1 = *__ctype_b_loc()",
    "if ((zx.d(rdx_1[zx.q(*var_40)]) & 0x2000) == 0)",
    "var_48 += 1",
    "var_40 = &var_40[1]",
    "int64_t result",
    "if ((zx.q(var_48.d) & 1) == 0)",
    "uint64_t bytes = var_48 u>> 1",
    "int64_t result_1 = malloc(bytes)",
    "if (result_1 != 0)",
    "void* i = nullptr",
    "void* var_30_1 = nullptr",
    "while (i u< bytes)",
    "while ((zx.d((*__ctype_b_loc())[zx.q(*(var_30_1 + arg1))]) & 0x2000) != 0)",
    "var_30_1 += 1",
    "char nptr = *(var_30_1 + arg1)",
    "char var_12_1 = *(arg1 + var_30_1 + 1)",
    "char var_11_1 = 0",
    "*(i + result_1) = strtol(&nptr, nullptr, 0x10)",
    "var_30_1 += 2",
    "i += 1",
    "if (arg2 != 0)",
    "*arg2 = bytes",
    "result = result_1",
    "result = 0",
    "result = 0",
    "*(fsbase + 0x28)",
    "if (rax == *(fsbase + 0x28))",
    "return result",
    "__stack_chk_fail()",
    "noreturn"
  ]
}