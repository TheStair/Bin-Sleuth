{
  "address": "0x14005db80",
  "rules": [
    "encrypt data using XTEA/4b6117a2d51f4354afd7eb58ab16e151/1a6c04bed22346cdaee8fbdaa0f123d3",
    "empty recycle bin quietly/a401764de4c44240956dc7f3c78baebd",
    "contain loop",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e"
  ],
  "disassembly": [
    "mov     qword [rsp+0x8 {__saved_rbx}], rbx",
    "mov     qword [rsp+0x20 {arg_20}], r9",
    "mov     qword [rsp+0x18 {arg_18}], r8",
    "push    rbp {__saved_rbp}",
    "push    rsi {__saved_rsi}",
    "push    rdi {__saved_rdi}",
    "push    r12 {__saved_r12}",
    "push    r13 {__saved_r13}",
    "push    r14 {__saved_r14}",
    "push    r15 {__saved_r15}",
    "sub     rsp, 0x60",
    "mov     r13, r8",
    "mov     rbp, rdx",
    "mov     rdi, rcx",
    "xor     ebx, ebx  {0x0}",
    "xor     r12d, r12d  {0x0}",
    "call    sub_140019f68",
    "test    eax, eax",
    "jne     0x14005dbc4",
    "test    rbp, rbp",
    "lea     rsi, [rel data_1400f386c]",
    "cmovne  rsi, rbp",
    "and     dword [rdi+0x50], ebx  {0x0}",
    "cmp     qword [rdi+0x158], rbx",
    "je      0x14005dbe8",
    "mov     ecx, 0x1d465",
    "call    sub_140084e70",
    "jmp     0x14005de66",
    "cmp     byte [rsi], 0x0",
    "je      0x14005ddf9",
    "xor     edx, edx  {0x0}",
    "mov     rcx, rdi",
    "call    sub_1400190a0",
    "mov     rbx, qword [rsp+0xa0 {__saved_rbx}]",
    "add     rsp, 0x60",
    "pop     r15 {__saved_r15}",
    "pop     r14 {__saved_r14}",
    "pop     r13 {__saved_r13}",
    "pop     r12 {__saved_r12}",
    "pop     rdi {__saved_rdi}",
    "pop     rsi {__saved_rsi}",
    "pop     rbp {__saved_rbp}",
    "retn     {__return_addr}",
    "cmp     byte [rdi+0x61], 0x0",
    "jne     0x14005de0c",
    "xor     r15d, r15d  {0x0}",
    "lea     rax, [rsp+0x50 {var_48}]",
    "mov     r9d, 0x80",
    "and     qword [rsp+0x40 {var_58_1}], r15  {0x0}",
    "and     qword [rsp+0x48 {var_50}], r15  {0x0}",
    "mov     qword [rsp+0x30 {var_68_1}], rax {var_48}",
    "lea     rax, [rsp+0x48 {var_50}]",
    "or      r8d, 0xffffffff  {0xffffffff}",
    "mov     rdx, rsi",
    "mov     qword [rsp+0x28 {var_70_1}], rax {var_50}",
    "and     qword [rsp+0x20 {var_78}], r15  {0x0}",
    "mov     rcx, rdi",
    "call    sub_140062858",
    "mov     rbp, qword [rsp+0x48 {var_50}]",
    "mov     ebx, eax",
    "test    eax, eax",
    "jne     0x14005dddc",
    "mov     rcx, rdi",
    "call    sub_140016f38",
    "mov     ebx, eax  {0x7}",
    "cmp     ebx, 0xc0a",
    "je      0x14005de0c",
    "test    rbp, rbp",
    "je      0x14005dde9",
    "test    rbp, rbp",
    "jne     0x14005dc4a",
    "mov     rax, qword [rsp+0xc0 {arg5}]",
    "test    rax, rax",
    "je      0x14005de64",
    "mov     rsi, qword [rsp+0xc0 {arg5}]",
    "test    rsi, rsi",
    "je      0x14005de64",
    "and     ebx, dword [rdi+0x54]",
    "jmp     0x14005de16",
    "test    r12, r12",
    "je      0x14005ddf9",
    "mov     rcx, rbp",
    "call    sub_1400346ec",
    "xor     r14d, r14d  {0x0}",
    "mov     rsi, qword [rsp+0x50 {var_48}]",
    "jmp     0x14005ddad",
    "mov     eax, ebx",
    "and     qword [rax], 0x0",
    "mov     rcx, rdi",
    "call    sub_140083ee4",
    "xor     ecx, ecx  {0x0}",
    "mov     rdx, rax",
    "call    sub_140016dac",
    "mov     qword [rsi], rax",
    "test    rax, rax",
    "jne     0x14005de64",
    "test    ebx, ebx",
    "je      0x14005de53",
    "mov     rdx, r12",
    "mov     rcx, rdi",
    "call    sub_1400169a8",
    "cmp     ebx, 0x64",
    "je      0x14005dc4d",
    "cmp     eax, 0x64",
    "je      0x14005dc85",
    "test    ebx, ebx",
    "jne     0x14005dddc",
    "lea     ebx, [rax+0x7]",
    "mov     rcx, rdi",
    "mov     edx, ebx",
    "mov     dword [rdi+0x50], ebx",
    "call    sub_1400190a0",
    "jmp     0x14005de64",
    "mov     rcx, rbp",
    "call    sub_1400365fc",
    "mov     ebx, eax",
    "test    r13, r13",
    "je      0x14005dd6a",
    "mov     rcx, rbp",
    "call    sub_1400346ec",
    "mov     rsi, qword [rsp+0x50 {var_48}]",
    "xor     ebp, ebp  {0x0}",
    "mov     ebx, eax",
    "lea     r14, [rel data_1400d6500]",
    "jmp     0x14005dd90",
    "test    r14d, r14d",
    "jne     0x14005dce9",
    "cmp     eax, 0x65",
    "jne     0x14005dd6a",
    "jmp     0x14005dbe8",
    "movzx   eax, byte [rsi]",
    "test    byte [rax+r14], 0x1",
    "jne     0x14005dd8d",
    "cmp     ebx, 0x64",
    "jne     0x14005dd4d",
    "movzx   r15d, word [rbp+0xc0]",
    "mov     rcx, rdi",
    "lea     eax, [r15+r15+0x1]",
    "movsxd  rdx, eax",
    "shl     rdx, 0x3",
    "call    sub_140016c18",
    "mov     r12, rax",
    "test    rax, rax",
    "je      0x14005dddc",
    "test    r14d, r14d",
    "jne     0x14005dd73",
    "inc     rsi",
    "test    r12, r12",
    "je      0x14005ddaa",
    "mov     rax, qword [rsp+0x40 {var_58_1}]",
    "movsxd  rax, r15d",
    "xor     esi, esi  {0x0}",
    "xor     r13d, r13d  {0x0}",
    "lea     rax, [r12+rax*8]",
    "mov     qword [rsp+0x40 {var_58_1}], rax",
    "test    r15d, r15d",
    "jle     0x14005dd3e",
    "xor     esi, esi  {0x0}",
    "test    r15d, r15d",
    "jle     0x14005dce3",
    "mov     eax, dword [rdi+0x30]",
    "bt      rax, 0x8",
    "jae     0x14005dd73",
    "xor     r12d, r12d  {0x0}",
    "mov     rdx, r12",
    "mov     rcx, rdi",
    "call    sub_1400169a8",
    "mov     rcx, rbp",
    "mov     ebx, 0x4",
    "call    sub_1400346ec",
    "mov     edx, ebx  {0x4}",
    "mov     rcx, rdi",
    "xor     ebp, ebp  {0x0}",
    "mov     dword [rdi+0x50], ebx  {0x4}",
    "call    sub_1400190a0",
    "and     qword [rax+r13*8], 0x0",
    "mov     r13, qword [rsp+0xb0 {arg_18}]",
    "jmp     0x14005dd52",
    "mov     edx, esi",
    "mov     rcx, rbp",
    "call    sub_140036c30",
    "mov     rcx, qword [rsp+0x40 {var_58_1}]",
    "mov     qword [rcx+r13*8], rax",
    "test    rax, rax",
    "jne     0x14005dd2f",
    "mov     r14d, 0x1",
    "mov     r13, rax",
    "mov     rcx, qword [rsp+0xb8 {arg_20}]",
    "mov     r9, r12",
    "mov     r8, rax",
    "mov     edx, r15d",
    "call    r13",
    "test    eax, eax",
    "jne     0x14005ddc0",
    "inc     esi",
    "inc     r13",
    "cmp     esi, r15d",
    "jl      0x14005dd04",
    "mov     edx, esi",
    "mov     rcx, rbp",
    "call    sub_140036cf0",
    "cmp     eax, 0x5",
    "jne     0x14005ddb6",
    "xor     r9d, r9d  {0x0}",
    "xor     r8d, r8d  {0x0}",
    "mov     edx, esi",
    "mov     rcx, rbp",
    "call    sub_140036d2c",
    "inc     esi",
    "mov     qword [r13], rax",
    "add     r13, 0x8",
    "cmp     esi, r15d",
    "jl      0x14005dcbc",
    "mov     r13, qword [rsp+0xb0 {arg_18}]",
    "mov     rax, qword [rsp+0x40 {var_58_1}]",
    "mov     rcx, rdi",
    "call    sub_140016efc",
    "jmp     0x14005dddc"
  ],
  "high_level_IL": [
    "int64_t r13 = arg3",
    "int32_t rbx = 0",
    "int64_t* r12 = nullptr",
    "int32_t rax",
    "int512_t zmm0",
    "rax, zmm0 = sub_140019f68(arg1)",
    "if (rax == 0)",
    "return sub_140084e70(0x1d465, zmm0)",
    "void* const rsi_1 = &data_1400f386c",
    "if (arg2 != 0)",
    "rsi_1 = arg2",
    "arg1[0xa].d = 0",
    "if (arg1[0x2b] != 0)",
    "sub_1400190a0(arg1, 0)",
    "while (*rsi_1 != 0)",
    "uint32_t r15_1 = 0",
    "void* var_58_1 = nullptr",
    "int64_t* var_50 = nullptr",
    "void* var_48",
    "int32_t rax_2 = sub_140062858(arg1, rsi_1, 0xffffffff, 0x80, nullptr, &var_50, &var_48)",
    "int64_t* rbp_1 = var_50",
    "rbx = rax_2",
    "if (rax_2 == 0)",
    "if (rbp_1 != 0)",
    "int32_t r14_1 = 0",
    "while (true)",
    "int32_t rax_3",
    "int512_t zmm0_1",
    "int512_t zmm1_1",
    "rax_3, zmm0_1, zmm1_1 = sub_1400365fc(rbp_1)",
    "rbx = rax_3",
    "if (r13 == 0)",
    "label_14005dd6a:",
    "if (rbx == 0x64)",
    "continue",
    "if (rax_3 == 0x64)",
    "label_14005dc88:",
    "if (r14_1 == 0)",
    "r15_1 = zx.d(rbp_1[0x18].w)",
    "int64_t* rax_6 = sub_140016c18(arg1, sx.q(r15_1 * 2 + 1) << 3, zmm1_1)",
    "r12 = rax_6",
    "if (rax_6 == 0)",
    "break",
    "int32_t rsi_2 = 0",
    "if (r15_1 s> 0)",
    "int64_t* r13_1 = rax_6",
    "int64_t rax_7",
    "rax_7, zmm0_1 = sub_140036d2c(rbp_1, rsi_2, 0, zmm0_1)",
    "rsi_2 += 1",
    "*r13_1 = rax_7",
    "r13_1 = &r13_1[1]",
    "do while (rsi_2 s< r15_1)",
    "r13 = arg3",
    "r14_1 = 1",
    "void* rax_9",
    "if (rbx != 0x64)",
    "rax_9 = var_58_1",
    "int32_t rsi_3 = 0",
    "int64_t r13_2 = 0",
    "rax_9 = &r12[sx.q(r15_1)]",
    "var_58_1 = rax_9",
    "if (r15_1 s> 0)",
    "int64_t rax_10 = sub_140036c30(rbp_1, rsi_3)",
    "*(var_58_1 + (r13_2 << 3)) = rax_10",
    "if (rax_10 == 0 && sub_140036cf0(rbp_1, rsi_3) != 5)",
    "sub_140016efc(arg1)",
    "goto label_14005dddc",
    "rsi_3 += 1",
    "r13_2 += 1",
    "do while (rsi_3 s< r15_1)",
    "rax_9 = var_58_1",
    "*(rax_9 + (r13_2 << 3)) = 0",
    "r13 = arg3",
    "if (r13(arg4, zx.q(r15_1), rax_9, r12) == 0)",
    "goto label_14005dd6a",
    "rbx = 4",
    "sub_1400346ec(rbp_1)",
    "rbp_1 = nullptr",
    "arg1[0xa].d = 4",
    "sub_1400190a0(arg1, 4)",
    "break",
    "if (rax_3 != 0x65)",
    "goto label_14005dd6a",
    "if (r14_1 == 0 && test_bit(zx.q(arg1[6].d), 8))",
    "goto label_14005dc88",
    "int32_t rax_13 = sub_1400346ec(rbp_1)",
    "rsi_1 = var_48",
    "rbp_1 = nullptr",
    "rbx = rax_13",
    "while ((*(zx.q(*rsi_1) + &data_1400d6500) & 1) != 0)",
    "rsi_1 += 1",
    "if (r12 != 0)",
    "sub_1400169a8(arg1, r12)",
    "r12 = nullptr",
    "goto label_14005ddad",
    "rsi_1 = var_48",
    "label_14005ddad:",
    "if (rbx == 0)",
    "continue",
    "label_14005dddc:",
    "if (rbp_1 != 0)",
    "sub_1400346ec(rbp_1)",
    "if (r12 == 0)",
    "break",
    "sub_1400169a8(arg1, r12)",
    "break",
    "int32_t rbx_1",
    "if (*(arg1 + 0x61) != 0 || rbx == 0xc0a)",
    "sub_140016f38(arg1)",
    "rbx_1 = 7",
    "rbx_1 = rbx & *(arg1 + 0x54)",
    "if (rbx_1 == 0)",
    "if (arg5 != 0)",
    "*arg5 = 0",
    "if (arg5 != 0)",
    "int64_t rax_16 = sub_140016dac(nullptr, sub_140083ee4(arg1))",
    "*arg5 = rax_16",
    "if (rax_16 == 0)",
    "rbx_1 = (rax_16 + 7).d",
    "arg1[0xa].d = rbx_1",
    "sub_1400190a0(arg1, rbx_1)",
    "return zx.q(rbx_1)"
  ]
}