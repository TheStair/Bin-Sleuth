{
  "address": "0x140033130",
  "rules": [
    "encrypt data using XXTEA/3026d94f6eda43e0bed136bd89733650/0d7bc900a8ea48098fc469578ae14b88",
    "encrypt data using HC-128/86aaff13b46c4951b9ca4e0a9171c391",
    "hash data using aphash/c01783ca846f48c3a4751b50c0c12749",
    "check for time delay via GetTickCount/dcdc41ab318e4e618f624ba5aeac30b2",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e",
    "contain loop",
    "write file on Windows/035d57bed47747649158312e9532f27d",
    "decompress data using LZO/4cde8899b401464e87ec185666d6508a",
    "encrypt data using TEA/2e46a442f8994747bcdba3ad7ba7dd19/5f4c97f31ce341008ea23885a97305d8",
    "decrypt data using TEA/171baf30f6564bc494c3539bab277577/5f4855375d6b45e9bd6b2a189e856211",
    "encrypt data using XXTEA/031815fb14e94f2fb59fa9eb4980d745/dc118f3b61184df4a511ed4919cf656f",
    "hash data using jshash/f142a7a7597843a791ba4ccc676b6fb1"
  ],
  "disassembly": [
    "push    rbx {__saved_rbx}",
    "push    rbp {__saved_rbp}",
    "push    rsi {__saved_rsi}",
    "push    rdi {__saved_rdi}",
    "push    r12 {__saved_r12}",
    "push    r13 {__saved_r13}",
    "push    r14 {__saved_r14}",
    "push    r15 {__saved_r15}",
    "sub     rsp, 0x48",
    "mov     eax, dword [rcx+0xc8]",
    "mov     rbx, qword [rcx+0x68]",
    "mov     r13, qword [rcx]",
    "xor     r14d, r14d",
    "xor     r12d, r12d  {0x0}",
    "and     al, 0xc",
    "lea     edi, [r14+0x1]",
    "xor     r15d, r15d  {0x0}",
    "add     rbx, 0x38",
    "lea     edx, [rdi+0x3]  {0x4}",
    "mov     rsi, rcx",
    "mov     qword [rsp+0x98 {arg_10}], r12  {0x0}",
    "mov     qword [rsp+0x30 {var_58}], r13",
    "cmp     al, dl",
    "je      0x140033187",
    "mov     ebp, edi  {0x1}",
    "mov     eax, dword [r13+0x30]",
    "bt      rax, 0x18",
    "jb      0x140033187",
    "mov     r8d, dword [rsi+0x90]",
    "mov     dword [rsp+0x90 {arg_8}], r8d",
    "test    ebp, ebp",
    "je      0x14003320b",
    "mov     rcx, r13",
    "call    sub_140016efc",
    "jmp     0x14003358a",
    "xor     ebp, ebp  {0x0}",
    "jmp     0x140033189",
    "mov     r13d, dword [rsi+0x34]",
    "movsxd  r10, r14d",
    "movsxd  r9, ebp",
    "cmp     r13d, r8d",
    "lea     eax, [r13+0x1]",
    "mov     qword [rsp+0xa0 {arg_18}], r10",
    "mov     dword [rsi+0x34], eax",
    "mov     qword [rsp+0xa8 {arg_20}], r9",
    "jge     0x140033581",
    "mov     r15, qword [rsi+0x68]",
    "add     r15, 0x1f8",
    "test    byte [r15+0x8], 0x10",
    "je      0x1400331e9",
    "mov     eax, edi",
    "add     rsp, 0x48",
    "pop     r15 {__saved_r15}",
    "pop     r14 {__saved_r14}",
    "pop     r13 {__saved_r13}",
    "pop     r12 {__saved_r12}",
    "pop     rdi {__saved_rdi}",
    "pop     rsi {__saved_rsi}",
    "pop     rbp {__saved_rbp}",
    "pop     rbx {__saved_rbx}",
    "retn     {__return_addr}",
    "mov     edx, 0x8",
    "mov     rcx, rbx",
    "call    sub_140033070",
    "and     qword [rsi+0xa0], r12  {0x0}",
    "cmp     dword [rsi+0x38], 0x7",
    "jne     0x1400331b0",
    "mov     edi, 0x65",
    "mov     ebp, r14d",
    "shl     ebp, 0x3",
    "xor     ecx, ecx  {0x0}",
    "movsxd  rdx, r14d",
    "test    r14d, r14d",
    "jle     0x14003320b",
    "movsxd  r14, dword [r15+0xc]",
    "mov     r12, qword [r15+0x10]",
    "shr     r14, 0x3",
    "mov     qword [rsp+0x98 {arg_10}], r12",
    "sub     r13d, eax",
    "mov     rax, qword [r12]",
    "xor     edx, edx  {0x0}",
    "jmp     0x14003326b",
    "movsxd  rax, r13d",
    "lea     rcx, [rax+rax*2]",
    "mov     rax, qword [rsi+0x88]",
    "jmp     0x140033281",
    "mov     rax, qword [r12+rcx*8]",
    "add     rcx, rdi",
    "add     r8d, dword [rax+0x8]",
    "cmp     rcx, rdx",
    "jl      0x1400331f3",
    "mov     ecx, dword [rax+0x8]",
    "cmp     r13d, ecx",
    "jge     0x140033261",
    "lea     r12, [rax+rcx*8]",
    "test    r9, r9",
    "je      0x14003333e",
    "mov     dword [rsp+0x90 {arg_8}], r8d",
    "sub     r13d, ecx",
    "add     rdx, rdi",
    "mov     rax, qword [r12+rdx*8]",
    "mov     rdx, qword [r12+rdx*8]",
    "movsxd  rax, r13d",
    "lea     rcx, [rax+rax*2]",
    "mov     rax, qword [rdx]",
    "mov     eax, dword [rsi+0xc8]",
    "and     al, 0xc",
    "cmp     al, 0x8",
    "jb      0x140033386",
    "cmp     byte [r12+0x1], 0xfc",
    "jne     0x14003333e",
    "mov     rax, qword [rsp+0x30 {var_58}]",
    "mov     eax, dword [rax+0x160]",
    "test    eax, eax",
    "je      0x1400333b2",
    "cmp     byte [r12], 0xab",
    "je      0x140033386",
    "xor     ecx, ecx  {0x0}",
    "xor     eax, eax  {0x0}",
    "lea     edx, [rbp+0x8]",
    "test    r10, r10",
    "jle     0x1400332cb",
    "mov     eax, dword [rsi+0xc8]",
    "mov     edx, 0x4",
    "and     al, 0xc",
    "cmp     al, dl",
    "jne     0x1400333fa",
    "mov     ecx, 0x9",
    "mov     dword [rsi+0x38], ecx  {0x9}",
    "call    sub_14008335c",
    "mov     rcx, rsi",
    "mov     rdx, rax",
    "call    sub_140032200",
    "jmp     0x14003358a",
    "cmp     byte [r12], 0x3d",
    "jne     0x14003335d",
    "cmp     ecx, r14d",
    "jne     0x14003333e",
    "mov     r8, qword [r12+0x10]",
    "mov     r9, qword [rsp+0x98 {arg_10}]",
    "mov     word [rbx+0x8], dx  {0x4}",
    "movsxd  rax, dword [r12+0x4]",
    "mov     r14d, 0x64",
    "mov     qword [rbx], rax",
    "mov     word [rbx+0x40], dx  {0x4}",
    "movsxd  rax, dword [r12+0x8]",
    "mov     qword [rbx+0x38], rax",
    "mov     word [rbx+0x78], dx  {0x4}",
    "movsxd  rax, dword [r12+0xc]",
    "mov     qword [rbx+0x70], rax",
    "cmp     dword [rbx+0xc8], r14d",
    "jge     0x140033443",
    "mov     word [rbx+0x8], dx  {0x4}",
    "movsxd  rax, r13d",
    "lea     rcx, [rel data_1400d69b0]",
    "mov     qword [rbx], rax",
    "mov     eax, 0xa02",
    "mov     word [rbx+0x40], ax  {0xa02}",
    "movzx   eax, byte [r12]",
    "mov     rcx, qword [rcx+rax*8]",
    "mov     qword [rbx+0x48], rcx",
    "call    sub_140019074",
    "mov     byte [rbx+0x42], dil  {0x1}",
    "mov     dword [rbx+0x44], eax",
    "add     rbx, 0x70",
    "mov     r13d, dword [rsi+0x34]",
    "cmp     r13d, r8d",
    "lea     eax, [r13+0x1]",
    "mov     dword [rsi+0x34], eax",
    "jge     0x140033581",
    "cmp     dword [rsi+0x34], edi",
    "jg      0x140033386",
    "xor     r8d, r8d  {0x0}",
    "test    r14d, r14d",
    "mov     rcx, r15",
    "setne   r8b",
    "call    sub_140030d38",
    "mov     dword [rsi+0x38], eax",
    "test    eax, eax",
    "jne     0x14003358a",
    "mov     r8d, dword [rsp+0x90 {arg_8}]",
    "add     rax, rdi",
    "add     ecx, edi",
    "cmp     rax, r10",
    "jl      0x1400332b3",
    "mov     rax, qword [rbx+0xc0]",
    "and     word [rbx+0xb0], 0x2d",
    "mov     qword [rbx+0xb8], rax",
    "xor     eax, eax  {0x0}",
    "lea     rcx, [rbx+0xa8]",
    "xor     r8d, r8d  {0x0}",
    "mov     edx, r14d  {0x64}",
    "call    sub_140030d38",
    "jmp     0x14003345b",
    "mov     r12, qword [rsp+0x98 {arg_10}]",
    "mov     r9, qword [rsp+0xa8 {arg_20}]",
    "jmp     0x14003323b",
    "mov     rax, qword [r12+0x10]",
    "mov     r10, qword [rsp+0xa0 {arg_18}]",
    "mov     r9, qword [r15+0x10]",
    "mov     r8d, dword [rsp+0x90 {arg_8}]",
    "mov     qword [r9+r10*8], rax",
    "or      word [r15+0x8], 0x10",
    "add     ebp, 0x8",
    "add     r10, rdi",
    "add     r14d, edi",
    "mov     dword [r15+0xc], ebp",
    "mov     rax, qword [r12+0x10]",
    "mov     qword [rsp+0x98 {arg_10}], r9",
    "add     r8d, dword [rax+0x8]",
    "mov     qword [rsp+0xa0 {arg_18}], r10",
    "mov     dword [rsp+0x90 {arg_8}], r8d",
    "cmp     qword [r9+rax*8], r8",
    "je      0x1400332c3",
    "mov     r8d, dword [rbx+0xc8]",
    "mov     rdx, qword [rbx+0xb8]",
    "mov     r15d, 0x202",
    "mov     rcx, r12",
    "mov     word [rbx+0xb0], r15w  {0x202}",
    "call    sub_140032d68",
    "mov     rcx, qword [rbx+0xb8]",
    "cmp     rax, rcx",
    "je      0x1400334b8",
    "test    eax, eax",
    "jne     0x14003358a",
    "mov     eax, dword [rsi+0x90]",
    "cmp     r13d, eax",
    "jge     0x140033256",
    "call    sub_140019074",
    "mov     byte [rbx+0xb2], dil  {0x1}",
    "mov     dword [rbx+0xb4], eax",
    "and     dword [rbx+0xb4], 0x0",
    "and     qword [rsp+0x20 {var_68}], 0x0",
    "lea     rcx, [rbx+0xa8]",
    "mov     r9b, dil  {0x1}",
    "or      r8d, 0xffffffff  {0xffffffff}",
    "mov     rdx, rax",
    "call    sub_140031820",
    "jmp     0x1400334ca",
    "mov     eax, dword [rsi+0xc8]",
    "shr     eax, 0x2",
    "and     ax, r13w",
    "sub     ax, di",
    "mov     edi, r14d  {0x64}",
    "sub     bp, ax",
    "mov     rax, qword [rsi+0x68]",
    "shl     bp, 0x2",
    "add     rax, 0x38",
    "mov     qword [rsi+0xa0], rax",
    "mov     word [rsi+0xc0], bp",
    "jmp     0x140033586",
    "cmp     dword [rbx+0x100], edx",
    "jge     0x1400334fb",
    "mov     eax, dword [rsi+0xc8]",
    "mov     ebp, 0x2",
    "lea     edx, [rbp+0x2]  {0x4}",
    "and     al, 0xc",
    "lea     r13d, [rbp+0x1]  {0x3}",
    "cmp     al, dl",
    "jne     0x14003354f",
    "and     dword [rsi+0x38], 0x0",
    "mov     rax, qword [rbx+0xf8]",
    "and     word [rbx+0xe8], 0x2d",
    "mov     qword [rbx+0xf0], rax",
    "xor     eax, eax  {0x0}",
    "lea     rcx, [rbx+0xe0]",
    "xor     r8d, r8d  {0x0}",
    "call    sub_140030d38",
    "jmp     0x140033513",
    "mov     rdx, qword [rbx+0xf0]",
    "mov     word [rbx+0xe8], r15w  {0x202}",
    "mov     dword [rbx+0xec], ebp  {0x2}",
    "movzx   r9d, word [r12+0x2]",
    "lea     r8, [rel data_1400f4098]  {\"%.2x\"}",
    "mov     ecx, r13d  {0x3}",
    "call    _fprintf_p_l",
    "mov     byte [rbx+0xea], dil  {0x1}",
    "mov     word [rbx+0x120], di  {0x1}",
    "test    eax, eax",
    "jne     0x14003358a"
  ],
  "high_level_IL": [
    "void* r13 = *arg1",
    "uint32_t r14 = 0",
    "int64_t* r12 = nullptr",
    "int32_t rdi = 1",
    "int64_t* r15 = nullptr",
    "void* rbx_1 = arg1[0xd] + 0x38",
    "arg_10 = nullptr",
    "int32_t rbp",
    "if (((arg1[0x19].d).b & 0xc) == 4 || test_bit(zx.q(*(r13 + 0x30)), 0x18))",
    "rbp = 1",
    "rbp = 0",
    "int512_t zmm0 = sub_140033070(rbx_1, 8)",
    "arg1[0x14] = 0",
    "if (arg1[7].d != 7)",
    "int32_t r8_1 = arg1[0x12].d",
    "arg_8 = r8_1",
    "if (rbp != 0)",
    "r15 = arg1[0xd] + 0x1f8",
    "if ((r15[1].b & 0x10) != 0)",
    "r12 = r15[2]",
    "r14 = (sx.q(*(r15 + 0xc)) u>> 3).d",
    "arg_10 = r12",
    "int64_t i = 0",
    "if (r14 s> 0)",
    "int64_t rax_2 = r12[i]",
    "i += 1",
    "r8_1 += *(rax_2 + 8)",
    "do while (i s< sx.q(r14))",
    "arg_8 = r8_1",
    "int32_t r13_1 = *(arg1 + 0x34)",
    "int64_t r10_1 = sx.q(r14)",
    "int64_t r9_1 = sx.q(rbp)",
    "arg_18 = r10_1",
    "*(arg1 + 0x34) = r13_1 + 1",
    "arg_20 = r9_1",
    "if (r13_1 s>= r8_1)",
    "label_140033581:",
    "rdi = 0x65",
    "uint32_t rbp_2 = r14 << 3",
    "while (true)",
    "int32_t rax_4 = arg1[0x12].d",
    "int64_t rax_6",
    "int64_t rcx_2",
    "if (r13_1 s>= rax_4)",
    "r13_1 -= rax_4",
    "void* rax_7 = *r12",
    "int64_t rdx_2 = 0",
    "while (true)",
    "int32_t rcx_3 = *(rax_7 + 8)",
    "if (r13_1 s< rcx_3)",
    "break",
    "r13_1 -= rcx_3",
    "rdx_2 += 1",
    "rax_7 = r12[rdx_2]",
    "rcx_2 = sx.q(r13_1) * 3",
    "rax_6 = *r12[rdx_2]",
    "rcx_2 = sx.q(r13_1) * 3",
    "rax_6 = arg1[0x11]",
    "char* r12_1 = rax_6 + (rcx_2 << 3)",
    "int512_t zmm1",
    "if (r9_1 != 0 && r12_1[1] == 0xfc)",
    "int32_t rcx_4 = 0",
    "int64_t rax_9 = 0",
    "if (r10_1 s> 0)",
    "while (arg_10[rax_9] != *(r12_1 + 0x10))",
    "rax_9 += 1",
    "rcx_4 += 1",
    "if (rax_9 s>= r10_1)",
    "break",
    "r8_1 = arg_8",
    "if (rcx_4 == r14)",
    "int32_t r8_3",
    "r8_3.b = r14 != 0",
    "int32_t rax_10",
    "rax_10, zmm0, zmm1 = sub_140030d38(r15, rbp_2 + 8, r8_3, zmm1)",
    "arg1[7].d = rax_10",
    "if (rax_10 != 0)",
    "return zx.q(rdi)",
    "int64_t* r9_3 = r15[2]",
    "r9_3[arg_18] = *(r12_1 + 0x10)",
    "r15[1].w |= 0x10",
    "rbp_2 += 8",
    "r10_1 = arg_18 + 1",
    "r14 += 1",
    "*(r15 + 0xc) = rbp_2",
    "arg_10 = r9_3",
    "r8_1 = arg_8 + *(*(r12_1 + 0x10) + 8)",
    "arg_18 = r10_1",
    "arg_8 = r8_1",
    "if (((arg1[0x19].d).b & 0xc) u>= 8 && *r12_1 != 0xab && (*r12_1 != 0x3d || *(arg1 + 0x34) s<= 1))",
    "r13_1 = *(arg1 + 0x34)",
    "*(arg1 + 0x34) = r13_1 + 1",
    "if (r13_1 s>= r8_1)",
    "goto label_140033581",
    "r12 = arg_10",
    "r9_1 = arg_20",
    "continue",
    "if (*(r13 + 0x160) != 0)",
    "arg1[7].d = 9",
    "char* rax_17",
    "int64_t r8_5",
    "rax_17, r8_5 = sub_14008335c(9)",
    "sub_140032200(arg1, rax_17, r8_5, zmm0)",
    "return zx.q(rdi)",
    "if (((arg1[0x19].d).b & 0xc) == 4)",
    "*(rbx_1 + 8) = 4",
    "*rbx_1 = sx.q(r13_1)",
    "*(rbx_1 + 0x40) = 0xa02",
    "int64_t rcx_7 = (&data_1400d69b0)[zx.q(*r12_1)]",
    "*(rbx_1 + 0x48) = rcx_7",
    "int32_t rax_21 = sub_140019074(rcx_7)",
    "*(rbx_1 + 0x42) = 1",
    "*(rbx_1 + 0x44) = rax_21",
    "rbx_1 += 0x70",
    "*(rbx_1 + 8) = 4",
    "*rbx_1 = sx.q(*(r12_1 + 4))",
    "*(rbx_1 + 0x40) = 4",
    "*(rbx_1 + 0x38) = sx.q(*(r12_1 + 8))",
    "*(rbx_1 + 0x78) = 4",
    "*(rbx_1 + 0x70) = sx.q(*(r12_1 + 0xc))",
    "int32_t rax_25",
    "if (*(rbx_1 + 0xc8) s>= 0x64)",
    "int64_t rax_26 = *(rbx_1 + 0xc0)",
    "*(rbx_1 + 0xb0) &= 0x2d",
    "*(rbx_1 + 0xb8) = rax_26",
    "rax_25 = 0",
    "rax_25, zmm0 = sub_140030d38(rbx_1 + 0xa8, 0x64, 0, zmm1)",
    "if (rax_25 != 0)",
    "return zx.q(rdi)",
    "uint64_t r8_6 = zx.q(*(rbx_1 + 0xc8))",
    "char* rdx_6 = *(rbx_1 + 0xb8)",
    "*(rbx_1 + 0xb0) = 0x202",
    "char* rax_27",
    "int512_t zmm0_1",
    "int512_t zmm1_1",
    "rax_27, zmm0_1, zmm1_1 = sub_140032d68(r12_1, rdx_6, r8_6, zmm0)",
    "int64_t rcx_10 = *(rbx_1 + 0xb8)",
    "if (rax_27 == rcx_10)",
    "int32_t rax_28 = sub_140019074(rcx_10)",
    "*(rbx_1 + 0xb2) = 1",
    "*(rbx_1 + 0xb4) = rax_28",
    "*(rbx_1 + 0xb4) = 0",
    "zmm0_1, zmm1_1 = sub_140031820(rbx_1 + 0xa8, rax_27, 0xffffffff, 1, r12_1, zmm1_1, 0)",
    "if (((arg1[0x19].d).b & 0xc) == 4)",
    "int32_t rax_30",
    "if (*(rbx_1 + 0x100) s>= 4)",
    "int64_t rax_31 = *(rbx_1 + 0xf8)",
    "*(rbx_1 + 0xe8) &= 0x2d",
    "*(rbx_1 + 0xf0) = rax_31",
    "rax_30 = 0",
    "rax_30, zmm0_1 = sub_140030d38(rbx_1 + 0xe0, 4, 0, zmm1_1)",
    "if (rax_30 != 0)",
    "return zx.q(rdi)",
    "int64_t rdx_8 = *(rbx_1 + 0xf0)",
    "*(rbx_1 + 0xe8) = 0x202",
    "*(rbx_1 + 0xec) = 2",
    "_fprintf_p_l(3, rdx_8, \"%.2x\", zx.q(*(r12_1 + 2)), zmm0_1)",
    "*(rbx_1 + 0xea) = 1",
    "*(rbx_1 + 0x120) = 1",
    "rdi = 0x64",
    "int16_t rbp_3 = (2 - (((arg1[0x19].d u>> 2).w & 3) - 1)) << 2",
    "arg1[0x14] = arg1[0xd] + 0x38",
    "arg1[0x18].w = rbp_3",
    "break",
    "arg1[7].d = 0",
    "sub_140016efc(r13)",
    "return zx.q(rdi)"
  ]
}