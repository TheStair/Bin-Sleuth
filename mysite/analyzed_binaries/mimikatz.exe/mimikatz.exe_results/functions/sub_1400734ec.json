{
  "address": "0x1400734ec",
  "rules": [
    "write file on Windows/035d57bed47747649158312e9532f27d",
    "check for time delay via GetTickCount/dcdc41ab318e4e618f624ba5aeac30b2",
    "connect to WMI namespace via WbemLocator/50f8c95bd151440fa4fe29260efaf440",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e",
    "contain loop"
  ],
  "disassembly": [
    "mov     qword [rsp+0x8 {__saved_rbx}], rbx",
    "mov     qword [rsp+0x18 {__saved_rbp}], rbp",
    "mov     qword [rsp+0x20 {__saved_rsi}], rsi",
    "push    rdi {__saved_rdi}",
    "push    r12 {__saved_r12}",
    "push    r13 {__saved_r13}",
    "push    r14 {__saved_r14}",
    "push    r15 {__saved_r15}",
    "sub     rsp, 0x40",
    "cmp     byte [rdx], 0xa7",
    "mov     r13, r9",
    "mov     rdi, r8",
    "mov     r11, rdx",
    "mov     r14, rcx",
    "jne     0x14007361b",
    "cmp     byte [rdx], 0x34",
    "je      0x14007362a",
    "mov     rbx, qword [rdx+0x20]",
    "test    rbx, rbx",
    "je      0x140073617",
    "mov     r8, qword [r11+0x10]",
    "mov     rcx, qword [r11+0x18]",
    "xor     edx, edx  {0x0}",
    "cmp     byte [r8], 0xa2",
    "lea     ebp, [rdx+0x1]",
    "jne     0x140073647",
    "cmp     byte [rdx], 0xa6",
    "je      0x14007362a",
    "xor     eax, eax  {0x0}",
    "jmp     0x140073691",
    "cmp     dword [rbx], 0x2",
    "jne     0x140073617",
    "test    rcx, rcx",
    "je      0x140073666",
    "mov     rax, qword [r8+0x40]",
    "cmp     dword [rax+0x54], edx",
    "cmovne  edx, ebp  {0x1}",
    "cmp     byte [rdx], 0x33",
    "jne     0x140073617",
    "lea     r11, [rsp+0x40 {__saved_r15}]",
    "mov     rbx, qword [r11+0x30 {__saved_rbx}]",
    "mov     rbp, qword [r11+0x40 {__saved_rbp}]",
    "mov     rsi, qword [r11+0x48 {__saved_rsi}]",
    "mov     rsp, r11",
    "pop     r15 {__saved_r15}",
    "pop     r14 {__saved_r14}",
    "pop     r13 {__saved_r13}",
    "pop     r12 {__saved_r12}",
    "pop     rdi {__saved_rdi}",
    "retn     {__return_addr}",
    "mov     r12, qword [rbx+0x30]",
    "mov     ebp, 0x1",
    "cmp     byte [r12], 0xa2",
    "jne     0x140073575",
    "cmp     byte [r11], 0x34",
    "mov     rax, qword [rsp+0x90 {arg5}]",
    "mov     qword [r9], r8",
    "mov     qword [rax], rcx",
    "jne     0x14007367d",
    "cmp     byte [rcx], 0xa2",
    "jne     0x140073666",
    "mov     rsi, qword [rbx+0x8]",
    "cmp     byte [rsi], 0xa2",
    "jne     0x140073617",
    "mov     rax, qword [r12+0x40]",
    "cmp     dword [rax+0x54], 0x0",
    "je      0x140073575",
    "cmp     byte [r11], 0xa6",
    "jne     0x140073686",
    "mov     byte [rdi], 0x44",
    "mov     rax, qword [rcx+0x40]",
    "cmp     dword [rax+0x54], 0x0",
    "je      0x140073666",
    "mov     rax, qword [rsi+0x40]",
    "cmp     dword [rax+0x54], 0x0",
    "je      0x140073617",
    "xor     esi, esi  {0x0}",
    "lea     r15, [rel data_1400d8760]",
    "cmp     byte [r11], 0x33",
    "jne     0x14007368f",
    "mov     byte [rdi], 0x45",
    "mov     rax, r8",
    "mov     r8, rcx",
    "add     edx, ebp",
    "mov     rcx, rax",
    "mov     rax, qword [rax+0x60]",
    "jmp     0x1400735c6",
    "mov     rdx, qword [rbx+0x8]",
    "movsxd  rcx, esi",
    "mov     qword [r13], r12",
    "add     rcx, rcx",
    "mov     cl, byte [r15+rcx*8+0x8]",
    "mov     byte [rdi], cl",
    "mov     rcx, qword [rsp+0x90 {arg5}]",
    "mov     qword [rcx], rdx",
    "add     esi, ebp",
    "cmp     esi, 0x4",
    "jl      0x140073557",
    "mov     eax, edx",
    "mov     byte [rdi], 0x46",
    "test    rax, rax",
    "jne     0x1400735bd",
    "mov     rcx, qword [r11+0x8]",
    "movsxd  rdx, esi",
    "add     rdx, rdx",
    "mov     rdx, qword [r15+rdx*8]",
    "call    sub_1400192b0",
    "test    eax, eax",
    "je      0x140073596",
    "cmp     qword [rax], r14",
    "je      0x1400735cb",
    "mov     rcx, qword [rax+0x10]",
    "mov     rax, qword [rcx]",
    "mov     r10, qword [rax+0x90]",
    "test    r10, r10",
    "je      0x140073617",
    "mov     rax, qword [rax+0x28]",
    "mov     r8, qword [r11+0x8]",
    "lea     rax, [rsp+0x78 {arg_10}]",
    "lea     r9, [rsp+0x30 {var_38}]",
    "mov     edx, 0x2",
    "mov     qword [rsp+0x20 {var_48_1}], rax {arg_10}",
    "call    r10",
    "cmp     eax, 0x96",
    "jl      0x140073617",
    "mov     rcx, qword [rbx+0x30]",
    "mov     byte [rdi], al",
    "mov     rax, qword [rsp+0x90 {arg5}]",
    "mov     qword [rax], rcx",
    "mov     qword [r13], rsi",
    "jmp     0x1400735b6",
    "mov     eax, ebp  {0x1}",
    "jmp     0x140073691"
  ],
  "high_level_IL": [
    "if (*arg2 == 0xa7)",
    "int32_t* rbx_1 = *(arg2 + 0x20)",
    "if (rbx_1 != 0 && *rbx_1 == 2)",
    "char* r12_1 = *(rbx_1 + 0x30)",
    "if (*r12_1 == 0xa2 && *(*(r12_1 + 0x40) + 0x54) != 0)",
    "int32_t rsi_1 = 0",
    "while (true)",
    "if (sub_1400192b0(*(arg2 + 8), (&data_1400d8760)[sx.q(rsi_1) * 2]) == 0)",
    "int64_t rdx_3 = *(rbx_1 + 8)",
    "*arg4 = r12_1",
    "int64_t rcx_2",
    "rcx_2.b = *(sx.q(rsi_1) * 0x10 + 0x1400d8768)",
    "*arg3 = rcx_2.b",
    "*arg5 = rdx_3",
    "break",
    "rsi_1 += 1",
    "if (rsi_1 s>= 4)",
    "goto label_140073575",
    "return 1",
    "label_140073575:",
    "char* rsi_2 = *(rbx_1 + 8)",
    "if (*rsi_2 == 0xa2)",
    "void* rax_3 = *(rsi_2 + 0x40)",
    "if (*(rax_3 + 0x54) != 0)",
    "int64_t* i",
    "i = *(rax_3 + 0x60)",
    "while (i != 0)",
    "if (*i == arg1)",
    "break",
    "i = i[5]",
    "int64_t r10_1 = *(*i[2] + 0x90)",
    "if (r10_1 != 0)",
    "void* var_48_1 = &arg_10",
    "int32_t rax_5 = r10_1()",
    "if (rax_5 s>= 0x96)",
    "int64_t rcx_5 = *(rbx_1 + 0x30)",
    "*arg3 = rax_5.b",
    "*arg5 = rcx_5",
    "*arg4 = rsi_2",
    "return 1",
    "if (*arg2 == 0x34 || *arg2 == 0xa6 || *arg2 == 0x33)",
    "char* r8 = *(arg2 + 0x10)",
    "char* rcx_6 = *(arg2 + 0x18)",
    "int32_t rdx_4 = 0",
    "if (*r8 == 0xa2 && *(*(r8 + 0x40) + 0x54) != 0)",
    "rdx_4 = 1",
    "if (rcx_6 != 0 && *rcx_6 == 0xa2 && *(*(rcx_6 + 0x40) + 0x54) != 0)",
    "char* rax_9 = r8",
    "r8 = rcx_6",
    "rdx_4 += 1",
    "rcx_6 = rax_9",
    "bool cond:2_1 = *arg2 != 0x34",
    "*arg4 = r8",
    "*arg5 = rcx_6",
    "if (not(cond:2_1))",
    "*arg3 = 0x44",
    "if (*arg2 == 0xa6)",
    "*arg3 = 0x45",
    "if (*arg2 == 0x33)",
    "*arg3 = 0x46",
    "return zx.q(rdx_4)",
    "return 0"
  ]
}