{
  "address": "0x14003df84",
  "rules": [
    "encrypt data using XXTEA/031815fb14e94f2fb59fa9eb4980d745/dc118f3b61184df4a511ed4919cf656f",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e",
    "encrypt data using TEA/2e46a442f8994747bcdba3ad7ba7dd19/5f4c97f31ce341008ea23885a97305d8",
    "decrypt data using TEA/171baf30f6564bc494c3539bab277577/5f4855375d6b45e9bd6b2a189e856211",
    "hash data with CRC32/dc8063c9cb1c41b9a5bafe66f5117ac4",
    "check for time delay via GetTickCount/dcdc41ab318e4e618f624ba5aeac30b2",
    "connect to WMI namespace via WbemLocator/50f8c95bd151440fa4fe29260efaf440",
    "empty recycle bin quietly/a401764de4c44240956dc7f3c78baebd",
    "decompress data using aPLib/88da69e00a6e49ce8c080be3a0beeb89"
  ],
  "disassembly": [
    "mov     qword [rsp+0x8 {__saved_rbx}], rbx",
    "mov     qword [rsp+0x10 {__saved_rbp}], rbp",
    "mov     qword [rsp+0x18 {__saved_rsi}], rsi",
    "push    rdi {__saved_rdi}",
    "push    r12 {__saved_r12}",
    "push    r13 {__saved_r13}",
    "sub     rsp, 0x20",
    "mov     rsi, qword [rcx+0x18]",
    "xor     ebp, ebp",
    "mov     rbx, rcx",
    "mov     rax, qword [rsi+0x68]",
    "lea     ecx, [rbp+0x4]",
    "mov     r13, r8",
    "mov     word [rax+0x40], cx  {0x4}",
    "mov     rax, qword [rsi+0x68]",
    "mov     r12, rdx",
    "mov     qword [rax+0x38], rdx",
    "cmp     dword [rsi+0x34], ecx",
    "jle     0x14003dfd0",
    "mov     rcx, qword [rbx+0x18]",
    "call    sub_1400365fc",
    "mov     dword [rsi+0x34], ecx  {0x4}",
    "mov     rcx, rsi",
    "call    sub_140037be8",
    "jmp     0x14003dfd9",
    "mov     rcx, qword [rbx+0x18]",
    "test    rcx, rcx",
    "je      0x14003e0e9",
    "mov     rax, qword [rsi+0x78]",
    "movzx   r9d, word [rbx+0x8]",
    "mov     r8, qword [rax]",
    "cmp     word [r8+0x52], r9w",
    "jbe     0x14003dffe",
    "mov     edi, eax",
    "cmp     eax, 0x64",
    "jne     0x14003e04d",
    "mov     rbx, qword [rsp+0x40 {__saved_rbx}]",
    "mov     rsi, qword [rsp+0x50 {__saved_rsi}]",
    "mov     qword [r13], rbp",
    "mov     rbp, qword [rsp+0x48 {__saved_rbp}]",
    "mov     eax, edi",
    "add     rsp, 0x20",
    "pop     r13 {__saved_r13}",
    "pop     r12 {__saved_r12}",
    "pop     rdi {__saved_rdi}",
    "retn     {__return_addr}",
    "call    sub_140035c54",
    "and     qword [rbx+0x18], 0x0",
    "mov     rcx, qword [rbx+0x20]",
    "mov     edi, eax",
    "test    eax, eax",
    "jne     0x14003e0ce",
    "xor     edx, edx  {0x0}",
    "movzx   eax, r9w",
    "mov     edx, dword [r8+rax*4+0x78]",
    "jmp     0x14003e000",
    "call    sub_140083ee4",
    "mov     rcx, qword [rbx+0x20]",
    "lea     rdx, [rel data_1400f38e8]",
    "mov     r8, rax",
    "call    _printf_p_l",
    "lea     rdx, [rel data_1400f44d8]  {\"no such rowid: %lld\"}",
    "mov     r8, r12",
    "call    _printf_p_l",
    "mov     edi, 0x1",
    "jmp     0x14003e0e6",
    "movsx   rcx, word [r8+0x50]",
    "movzx   eax, r9w",
    "add     rcx, rax",
    "mov     eax, dword [r8+rcx*4+0x78]",
    "mov     dword [rbx+0x4], eax",
    "cmp     edx, 0x80",
    "jb      0x14003e0a7",
    "mov     rcx, qword [rbx+0x20]",
    "cmp     edx, 0x7",
    "lea     rax, [rel data_1400f44a8]",
    "lea     r8, [rel data_1400f44b0]  {\"integer\"}",
    "cmove   r8, rax  {data_1400f44a8, \"real\"}",
    "test    edx, edx",
    "lea     rax, [rel data_1400f44a0]",
    "lea     rdx, [rel data_1400f44b8]  {\"cannot open value of type %s\"}",
    "cmove   r8, rax  {data_1400f44a0, \"null\"}",
    "call    _printf_p_l",
    "mov     rcx, qword [rbx+0x18]",
    "mov     edi, 0x1",
    "mov     rbp, rax",
    "call    sub_140035c54",
    "and     qword [rbx+0x18], 0x0",
    "cmp     edx, 0xc",
    "jae     0x14003e084",
    "mov     rbp, rax",
    "lea     rcx, [rel data_1400d7110]",
    "mov     eax, edx",
    "movzx   edx, byte [rax+rcx]",
    "add     edx, 0xfffffff4",
    "shr     edx, 0x1",
    "jmp     0x14003e0b4",
    "mov     dword [rbx], edx",
    "mov     rax, qword [r8+0x38]",
    "mov     qword [rbx+0x10], rax",
    "or      byte [rax+0x1], 0x10",
    "mov     rax, qword [rax+0x8]",
    "mov     byte [rax+0x13], 0x1",
    "xor     edi, edi  {0x0}",
    "jmp     0x14003e0e9"
  ],
  "high_level_IL": [
    "int64_t* rsi = *(arg1 + 0x18)",
    "int64_t* rbp = nullptr",
    "*(rsi[0xd] + 0x40) = 4",
    "*(rsi[0xd] + 0x38) = arg2",
    "int32_t rax_2",
    "int512_t zmm0",
    "if (*(rsi + 0x34) s<= 4)",
    "rax_2, zmm0 = sub_1400365fc(*(arg1 + 0x18))",
    "*(rsi + 0x34) = 4",
    "rax_2, zmm0 = sub_140037be8(rsi, arg4)",
    "int32_t rdi = rax_2",
    "if (rax_2 != 0x64)",
    "label_14003e04d:",
    "int64_t* rcx_4 = *(arg1 + 0x18)",
    "if (rcx_4 != 0)",
    "int32_t rax_6",
    "int512_t zmm0_1",
    "rax_6, zmm0_1 = sub_140035c54(rcx_4)",
    "*(arg1 + 0x18) = 0",
    "void* rcx_5 = *(arg1 + 0x20)",
    "rdi = rax_6",
    "int64_t* rax_7",
    "if (rax_6 != 0)",
    "char* rax_13",
    "int512_t zmm0_2",
    "rax_13, zmm0_2 = sub_140083ee4(rcx_5)",
    "rax_7 = _printf_p_l(*(arg1 + 0x20), \"%s\", rax_13, zmm0_2)",
    "rax_7 = _printf_p_l(rcx_5, \"no such rowid: %lld\", arg2, zmm0_1)",
    "rdi = 1",
    "rbp = rax_7",
    "int16_t r9_1 = arg1[2].w",
    "void* r8 = *rsi[0xf]",
    "int32_t rdx",
    "if (*(r8 + 0x52) u<= r9_1)",
    "rdx = 0",
    "rdx = *(r8 + (zx.q(r9_1) << 2) + 0x78)",
    "if (rdx u< 0xc)",
    "char const* const r8_1 = \"integer\"",
    "if (rdx == 7)",
    "r8_1 = \"real\"",
    "if (rdx == 0)",
    "r8_1 = \"null\"",
    "rdi = 1",
    "rbp = _printf_p_l(*(arg1 + 0x20), \"cannot open value of type %s\", r8_1, zmm0)",
    "sub_140035c54(*(arg1 + 0x18))",
    "*(arg1 + 0x18) = 0",
    "goto label_14003e04d",
    "arg1[1] = *(r8 + ((sx.q(*(r8 + 0x50)) + zx.q(r9_1)) << 2) + 0x78)",
    "uint32_t rdx_2",
    "if (rdx u< 0x80)",
    "rdx_2 = zx.d(*(zx.q(rdx) + &data_1400d7110))",
    "rdx_2 = (rdx - 0xc) u>> 1",
    "*arg1 = rdx_2",
    "void* rax_11 = *(r8 + 0x38)",
    "*(arg1 + 0x10) = rax_11",
    "*(rax_11 + 1) |= 0x10",
    "*(*(rax_11 + 8) + 0x13) = 1",
    "rdi = 0",
    "*arg3 = rbp",
    "return zx.q(rdi)"
  ]
}