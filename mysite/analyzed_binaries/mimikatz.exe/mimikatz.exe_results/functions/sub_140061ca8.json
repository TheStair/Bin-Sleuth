{
  "address": "0x140061ca8",
  "rules": [
    "encrypt data using chaskey/4b6f9d91d05f46dd9aa3662f80cb6278",
    "hash data using djb2/1485ed9954f84e3481d22b64bc4cfca7",
    "hash data using jshash/79354a2ef36a4036b42806ea4b41f8bd",
    "write file on Windows/035d57bed47747649158312e9532f27d",
    "check for time delay via GetTickCount/dcdc41ab318e4e618f624ba5aeac30b2",
    "connect to WMI namespace via WbemLocator/50f8c95bd151440fa4fe29260efaf440",
    "validate payment card number using luhn algorithm with no lookup table/f595b07566ee46b3ba7870816078c34e",
    "contain loop"
  ],
  "disassembly": [
    "mov     qword [rsp+0x10 {__saved_rbx}], rbx",
    "mov     qword [rsp+0x18 {__saved_rbp}], rbp",
    "mov     qword [rsp+0x20 {__saved_rsi}], rsi",
    "push    rdi {__saved_rdi}",
    "push    r12 {__saved_r12}",
    "push    r13 {__saved_r13}",
    "sub     rsp, 0x40",
    "mov     rbp, qword [rcx]",
    "movsxd  r13, dword [rcx+0x10]",
    "mov     rdi, r8",
    "mov     rax, qword [rbp+0x20]",
    "mov     r12, r13",
    "mov     rsi, rcx",
    "shl     r12, 0x5",
    "mov     rdx, qword [rax+r12+0x18]",
    "mov     eax, 0xfffb",
    "and     word [rdx+0x72], ax",
    "inc     dword [rcx+0x1c]",
    "cmp     byte [rbp+0x61], 0x0",
    "je      0x140061d05",
    "test    r8, r8",
    "je      0x140061e82",
    "mov     rdx, qword [rdi+0x8]",
    "xor     r8d, r8d  {0x0}",
    "call    sub_140061bdc",
    "mov     eax, 0x1",
    "jmp     0x140061e84",
    "xor     eax, eax  {0x0}",
    "cmp     qword [r8+0x18], 0x0",
    "jne     0x140061d1e",
    "mov     rbx, qword [rsp+0x68 {__saved_rbx}]",
    "mov     rbp, qword [rsp+0x70 {__saved_rbp}]",
    "mov     rsi, qword [rsp+0x78 {__saved_rsi}]",
    "add     rsp, 0x40",
    "pop     r13 {__saved_r13}",
    "pop     r12 {__saved_r12}",
    "pop     rdi {__saved_rdi}",
    "retn     {__return_addr}",
    "mov     rbx, qword [r8+0x20]",
    "lea     rdx, [rel data_1400f66c0]  {\"create \"}",
    "mov     r8d, 0x7",
    "mov     rcx, rbx",
    "call    sub_1400192e8",
    "test    eax, eax",
    "jne     0x140061df6",
    "mov     rdx, qword [rdi+0x8]",
    "jmp     0x140061e7a",
    "mov     rdx, qword [rdi+0x8]",
    "test    rdx, rdx",
    "je      0x140061e77",
    "mov     bl, byte [rbp+0xb4]",
    "mov     byte [rbp+0xb4], r13b",
    "mov     rcx, qword [rdi+0x18]",
    "call    sub_140019bc0",
    "and     dword [rbp+0xb8], 0xfffffffe",
    "and     qword [rsp+0x30 {var_28}], 0x0",
    "mov     dword [rbp+0xb0], eax",
    "mov     qword [rbp+0xc0], rdi",
    "mov     rdx, qword [rdi+0x20]",
    "lea     rax, [rsp+0x60 {arg_8}]",
    "xor     r9d, r9d  {0x0}",
    "or      r8d, 0xffffffff  {0xffffffff}",
    "mov     qword [rsp+0x28 {var_30_1}], rax {arg_8}",
    "and     qword [rsp+0x20 {var_38}], 0x0",
    "mov     rcx, rbp",
    "call    sub_140062858",
    "mov     r11d, dword [rbp+0x50]",
    "mov     byte [rbp+0xb4], bl",
    "test    r11d, r11d",
    "je      0x140061de7",
    "xor     r8d, r8d  {0x0}",
    "mov     rcx, rsi",
    "test    rbx, rbx",
    "je      0x140061e09",
    "mov     rcx, qword [rsp+0x60 {arg_8}]",
    "call    sub_140035c54",
    "jmp     0x140061e82",
    "test    byte [rbp+0xb8], 0x1",
    "jne     0x140061de7",
    "mov     r8, qword [rbp+0x20]",
    "mov     rcx, rbp",
    "mov     r8, qword [r8+r12]",
    "call    sub_14004e0d8",
    "mov     rbx, rax",
    "test    rax, rax",
    "je      0x140061e59",
    "cmp     byte [rbx], 0x0",
    "jne     0x140061e77",
    "cmp     r11d, dword [rsi+0x14]",
    "jle     0x140061db4",
    "mov     rdx, qword [rdi+0x8]",
    "lea     rax, [rel data_1400f5ec0]",
    "lea     r8, [rel data_1400f66c8]  {\"orphan index\"}",
    "test    rbx, rbx",
    "mov     rcx, rsi",
    "cmovne  r8, rax  {data_1400f5ec0, \"invalid rootpage\"}",
    "jmp     0x140061e7d",
    "mov     rcx, qword [rdi+0x18]",
    "lea     rdx, [rax+0x58]",
    "call    sub_140019a68",
    "test    eax, eax",
    "je      0x140061e59",
    "cmp     r11d, 0x7",
    "jne     0x140061dc4",
    "mov     dword [rsi+0x14], r11d",
    "call    sub_140061bdc",
    "mov     edx, dword [rbx+0x58]",
    "cmp     edx, 0x2",
    "jl      0x140061e59",
    "cmp     r11d, 0x9",
    "je      0x140061de7",
    "mov     rcx, rbp",
    "call    sub_140016efc",
    "jmp     0x140061de7",
    "mov     rax, qword [rbx+0x18]",
    "mov     rcx, qword [rax+0x10]",
    "jmp     0x140061e52",
    "cmp     r11b, 0x6",
    "je      0x140061de7",
    "test    rcx, rcx",
    "jne     0x140061e44",
    "mov     rcx, rbp",
    "call    sub_140083ee4",
    "mov     rdx, qword [rdi+0x8]",
    "mov     rcx, rsi",
    "mov     r8, rax",
    "call    sub_140061bdc",
    "cmp     dword [rcx+0x58], edx",
    "jne     0x140061e4e",
    "jmp     0x140061e82",
    "mov     rcx, qword [rcx+0x28]",
    "cmp     rcx, rbx",
    "jne     0x140061e59"
  ],
  "high_level_IL": [
    "int64_t* rbp = *arg1",
    "int64_t r13 = sx.q(arg1[2].d)",
    "void* rdx = *(rbp[4] + (r13 << 5) + 0x18)",
    "*(rdx + 0x72) &= 0xfffb",
    "*(arg1 + 0x1c) += 1",
    "if (*(rbp + 0x61) != 0)",
    "sub_140061bdc(arg1, *(arg3 + 8), nullptr, arg4)",
    "return 1",
    "if (arg3 != 0)",
    "if (*(arg3 + 0x18) != 0)",
    "char* rbx_1 = *(arg3 + 0x20)",
    "if (sub_1400192e8(rbx_1, \"create \", 7, 0xfffb) != 0)",
    "void* rdx_2 = *(arg3 + 8)",
    "if (rdx_2 == 0 || (rbx_1 != 0 && *rbx_1 != 0))",
    "sub_140061bdc(arg1, rdx_2, nullptr, arg4)",
    "void* rax_5 = sub_14004e0d8(rbp, rdx_2, rbp[4][r13 * 4])",
    "if (rax_5 != 0 && sub_140019a68(*(arg3 + 0x18), rax_5 + 0x58) != 0)",
    "int32_t rdx_6 = *(rax_5 + 0x58)",
    "if (rdx_6 s>= 2)",
    "void* rcx_9 = *(*(rax_5 + 0x18) + 0x10)",
    "while (true)",
    "if (rcx_9 == 0)",
    "return 0",
    "if (*(rcx_9 + 0x58) == rdx_6 && rcx_9 != rax_5)",
    "break",
    "rcx_9 = *(rcx_9 + 0x28)",
    "char* r8_3 = \"orphan index\"",
    "if (rax_5 != 0)",
    "r8_3 = \"invalid rootpage\"",
    "sub_140061bdc(arg1, *(arg3 + 8), r8_3, arg4)",
    "rbx_1.b = *(rbp + 0xb4)",
    "*(rbp + 0xb4) = r13.b",
    "int32_t rax_3 = sub_140019bc0(*(arg3 + 0x18))",
    "rbp[0x17].d &= 0xfffffffe",
    "rbp[0x16].d = rax_3",
    "rbp[0x18] = arg3",
    "sub_140062858(rbp, *(arg3 + 0x20), 0xffffffff, 0, nullptr, &arg_8, 0)",
    "int32_t r11_1 = rbp[0xa].d",
    "*(rbp + 0xb4) = rbx_1.b",
    "if (r11_1 != 0 && (rbp[0x17].b & 1) == 0)",
    "if (r11_1 s> *(arg1 + 0x14))",
    "*(arg1 + 0x14) = r11_1",
    "if (r11_1 == 7)",
    "sub_140016efc(rbp)",
    "if (r11_1 != 9 && r11_1.b != 6)",
    "char* rax_4",
    "int512_t zmm0",
    "rax_4, zmm0 = sub_140083ee4(rbp)",
    "sub_140061bdc(arg1, *(arg3 + 8), rax_4, zmm0)",
    "sub_140035c54(arg_8)",
    "sub_140061bdc(arg1, *(arg3 + 8), nullptr, arg4)",
    "return 0"
  ]
}